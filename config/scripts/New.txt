


@ participant1.domains.connect_local(mydomain) 


@ utils.retry_until_true {
    participant1.domains.list_connected().exists(_.domainId == mydomain.id)
  } 

@ val bank = participant1.parties.enable("NewBank") 
bank: PartyId = NewBank::12209f481589...

@ val alice = participant1.parties.enable("NewAlice")  
alice: PartyId = NewAlice::12209f481589...

@ val bob = participant1.parties.enable("NewBob") 
bob: PartyId = NewBob::12209f481589...

@ utils.retry_until_true {
    participant1.parties.list().exists(_.party == bank) &&
    participant1.parties.list().exists(_.party == alice) &&
    participant1.parties.list().exists(_.party == bob)
  } 


@ println(s"Bank party: $bank") 
Bank party: NewBank::12209f481589...


@ println(s"Alice party: $alice")  
Alice party: NewAlice::12209f481589...


@ println(s"Bob party: $bob") 
Bob party: NewBob::12209f481589...


@ participant1.dars.upload("dars/RWA.dar") 


@ utils.retry_until_true {
    participant1.dars.list().exists(_.name == "RWA")
  } 


REUSE PARTY.......................

// --- Paste this whole block at once into the Canton console ---

import com.digitalasset.canton.topology.PartyId

def findPartyByPrefix(prefix: String): Option[PartyId] = {
  try {
    participant1.parties.list().find { p =>
      val partyObj = try p.party catch { case _: Throwable => null }
      partyObj != null && partyObj.toString.startsWith(prefix)
    }.map(_.party.asInstanceOf[PartyId])
  } catch {
    case _: Throwable => None
  }
}

def getOrReuseParty(identifierHint: String): PartyId = {
  val prefix = identifierHint + "::"
  findPartyByPrefix(prefix) match {
    case Some(existing) =>
      println(s"↪ Reusing existing party for '$identifierHint': ${existing.toString}")
      existing
    case None =>
      try {
        val enabled = participant1.parties.enable(identifierHint)
        println(s"✅ Enabled party: ${enabled.toString}")
        enabled.asInstanceOf[PartyId]
      } catch {
        case e: Throwable =>
          println(s"⚠ enable($identifierHint) failed: ${e.getMessage}. Re-querying...")
          findPartyByPrefix(prefix) match {
            case Some(existing2) =>
              println(s"↪ Found existing party after failed enable: ${existing2.toString}")
              existing2
            case None =>
              println(s"❌ Could not enable or find party '$identifierHint' after retry.")
              throw e
          }
      }
  }
}

// Use it:
val bank = getOrReuseParty("NewBank")
val alice = getOrReuseParty("NewAlice")
val bob   = getOrReuseParty("NewBob")

println(s"Assigned bank = ${bank.toString}")
println(s"Assigned alice = ${alice.toString}")
println(s"Assigned bob = ${bob.toString}")

-----------------------------------------------------

VERY IMP OPERAION --------------------------


// --- Paste entire block at once into the Canton REPL ---

import com.digitalasset.canton.topology.PartyId

// helper: find an existing party by prefix (returns PartyId)
def findPartyByPrefix(prefix: String): Option[PartyId] = {
  try {
    participant1.parties.list().find { p =>
      val partyObj = try p.party catch { case _: Throwable => null }
      partyObj != null && partyObj.toString.startsWith(prefix)
    }.map(_.party.asInstanceOf[PartyId])
  } catch {
    case _: Throwable => None
  }
}

// helper: enable or reuse a party
def getOrReuseParty(identifierHint: String): PartyId = {
  val prefix = identifierHint + "::"
  findPartyByPrefix(prefix) match {
    case Some(existing) =>
      println(s"↪ Reusing existing party for '$identifierHint': ${existing.toString}")
      existing
    case None =>
      try {
        val enabled = participant1.parties.enable(identifierHint)
        println(s"✅ Enabled party: ${enabled.toString}")
        enabled.asInstanceOf[PartyId]
      } catch {
        case e: Throwable =>
          println(s"⚠ enable($identifierHint) failed: ${e.getMessage}. Re-querying...")
          findPartyByPrefix(prefix) match {
            case Some(existing2) =>
              println(s"↪ Found existing party after failed enable: ${existing2.toString}")
              existing2
            case None =>
              println(s"❌ Could not enable or find party '$identifierHint' after retry.")
              throw e
          }
      }
  }
}

// helper: check if a user exists
def userExists(userId: String): Boolean = {
  try {
    val page = participant1.ledger_api.users.list()
    val users = try page.users catch { case _: Throwable => Seq.empty }
    users.exists(u => try u.id == userId catch { case _: Throwable => false })
  } catch {
    case _: Throwable => false
  }
}

// helper: create user if absent
def ensureUserExists(userId: String, primaryPartyOpt: Option[PartyId]): Unit = {
  if (userExists(userId)) {
    println(s"User already exists: $userId")
  } else {
    println(s"Creating user: $userId")
    try {
      primaryPartyOpt match {
        case Some(p) => participant1.ledger_api.users.create(id = userId, primaryParty = Some(p))
        case None    => participant1.ledger_api.users.create(id = userId, primaryParty = None)
      }
      println(s"Created user: $userId")
    } catch {
      case e: Throwable =>
        println(s"❌ Error creating user $userId: ${e.getMessage}")
        throw e
    }
  }
}

// helper: grant rights (idempotent-ish)
def grantRights(userId: String, actAsParties: Set[PartyId], readAsParties: Set[PartyId]): Unit = {
  try {
    participant1.ledger_api.users.rights.grant(
      id = userId,
      actAs = actAsParties,
      readAs = readAsParties,
      participantAdmin = false
    )
    println(s"Granted rights for user: $userId")
  } catch {
    case e: Throwable =>
      println(s"❌ Error granting rights to $userId: ${e.getMessage}")
      throw e
  }
}

// --- actual flow: find/enable parties then create users and grant rights ---
val bank  = getOrReuseParty("NewBank")
val alice = getOrReuseParty("NewAlice")
val bob   = getOrReuseParty("NewBob")

println(s"Parties: bank=${bank.toString}, alice=${alice.toString}, bob=${bob.toString}")

// create ledger users if absent
ensureUserExists("bank_admin", Some(bank))
ensureUserExists("alice_user", Some(alice))
  ensureUserExists("bob_user", Some(bob))

  // grant actAs/readAs rights
  grantRights("bank_admin", Set(bank), Set(bank))
  grantRights("alice_user", Set(alice), Set(alice))
  grantRights("bob_user", Set(bob), Set(bob))

  println("✅ Users created/granted (or already present).")




--------------------------------------------------------------





println("Ready to create AssetRegistry contracts and mint tokens")
@ println("RWA Platform setup completed successfully!") 
RWA Platform setup completed successfully!


@ println("All parties (Bank, Alice, Bob) are on participant1") 
All parties (Bank, Alice, Bob) are on participant1


@ println("Ready to create AssetRegistry contracts and mint tokens") 
Ready to create AssetRegistry contracts and mint tokens


@ val rwaPkg   = participant1.packages.find("TokenExample").head 
 

@ val rwaPackageId = rwaPkg.packageId 
rwaPackageId: String = "323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1"

@ println(s"RWA Package ID: $rwaPackageId") 
RWA Package ID: 323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1


  Step 1: Create AssetRegistry contracts for Gold and Silver

  Copy and paste these commands in your Canton console:

  // Create Gold AssetRegistry
  val createGoldRegistryCmd = ledger_api_utils.create(rwaPackageId,
  "TokenExample", "AssetRegistry", Map("admin" -> bank, "name" ->
  "Gold Token", "symbol" -> "GLD"))

  // Create Silver AssetRegistry  
  val createSilverRegistryCmd = ledger_api_utils.create(rwaPackageId,
  "TokenExample", "AssetRegistry", Map("admin" -> bank, "name" ->
  "Silver Token", "symbol" -> "SLV"))

  // Submit both registry creation commands
 
  participant1.ledger_api.commands.submit(Seq(bank),
  Seq(createGoldRegistryCmd, createSilverRegistryCmd))


  println("✓ Created Gold and Silver AssetRegistry contracts")



Step 1: Get registry references 
  (corrected syntax)

  // Get all AssetRegistry contracts for the bank

val registries = participant1.ledger_api.acs.of_party(bank).filter(_.templateId.isModuleEntity("TokenExample",
  "AssetRegistry"))


  // Find Gold registry
  val goldRegistry = registries.find(reg => reg.arguments("symbol").toString.contains("GLD")).get



  // Find Silver registry  
  val silverRegistry =registries.find(reg => reg.arguments("symbol").toString.contains("SLV")).get

  println("✓ Retrieved Gold and Silver registry references")



  Step 2: Mint tokens to users

  // Mint 100 Gold tokens to Alice and 
  50 Gold tokens to Bob

  val mintAliceGoldCmd =
  ledger_api_utils.exercise("Mint",Map("to" -> alice, "amount" -> 100),goldRegistry.event)


   val mintBobGoldCmd =
  ledger_api_utils.exercise("Mint",
  Map("to" -> bob, "amount" -> 50),
  goldRegistry.event)



   participant1.ledger_api.commands.submit(Seq(bank), Seq(mintAliceGoldCmd,
  mintBobGoldCmd))



  Step 3: Mint Silver tokens

  // Mint 100 Silver tokens to Alice and
   50 Silver tokens to Bob  
  val mintAliceSilverCmd =
  ledger_api_utils.exercise("Mint",
  Map("to" -> alice, "amount" -> 100),
  silverRegistry.event)
  val mintBobSilverCmd =
  ledger_api_utils.exercise("Mint",
  Map("to" -> bob, "amount" -> 50),
  silverRegistry.event)

  participant1.ledger_api.commands.submit(Seq(bank), Seq(mintAliceSilverCmd,
  mintBobSilverCmd))
  println("✓ Minted Silver tokens: Alice
   100 SLV, Bob 50 SLV")


  Step 4: Check token balances

  // Check Alice's tokens
  val aliceTokens = participant1.ledger_api.acs.of_party(alice).filter(_.templateId.isModuleEntity("TokenExample",
  "Token"))

  aliceTokens.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Alice has $amount $symbol tokens")
  }

  // Check Bob's tokens  
  val bobTokens = participant1.ledger_api.acs.of_party(bob).filter(_.templateId.isModuleEntity("TokenExample",
  "Token"))
  bobTokens.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Bob has $amount $symbol tokens")
  }


println(s"Bank has ${bankContracts.size} active contracts:")
bankContracts.foreach { contract =>println(s"  - ${contract.templateId.entityName}: ${contract.contractId}")}

  Step 5: Test Token Transfer 
  Functionality


  // Get fresh registry references
  val currentRegistries = participant1.ledger_api.acs.of_party(bank).filter(_.templateId.isModuleEntity("TokenExample",
  "AssetRegistry"))

  // Find current Gold registry
  val goldRegistry =
  currentRegistries.find(reg => reg.arguments
  ("symbol").toString.contains("GLD")).get

  // Find current Silver registry  
  val silverRegistry =
  currentRegistries.find(reg => reg.arguments
  ("symbol").toString.contains("SLV")).get



 // Transfer Gold tokens from Alice to Bob (30 GLD)

  println("=== Testing Token Transfers ===")

  // Alice transfers 30 Gold to Bob
  val transferGoldCmd =
  ledger_api_utils.exercise("Transfer",
  Map("sender" -> alice, "recipient" ->
  bob, "amount" -> 30),
  goldRegistry.event)

  participant1.ledger_api.commands.submit(Seq(alice, bank), Seq(transferGoldCmd))
  println("✓ Alice transferred 30 GLD to Bob")

  Transfer Silver tokens from Bob to 
  Alice (20 SLV)

  // Bob transfers 20 Silver to Alice
  val transferSilverCmd =
  ledger_api_utils.exercise("Transfer",
  Map("sender" -> bob, "recipient" ->
  alice, "amount" -> 20),
  silverRegistry.event)

  participant1.ledger_api.commands.submit(Seq(bob, bank), Seq(transferSilverCmd))
  println("✓ Bob transferred 20 SLV to 
  Alice")

  Check updated balances after transfers

  println("=== Updated Balances After 
  Transfers ===")

  // Check Alice's updated tokens
  val aliceTokensAfter =
  participant1.ledger_api.acs.of_party(alice).filter(_.templateId.isModuleEntity("TokenExample", "Token"))
  aliceTokensAfter.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Alice now has $amount $symbol tokens")
  }

  // Check Bob's updated tokens  
  val bobTokensAfter = participant1.ledger_api.acs.of_party(bob).filter(_.templateId.isModuleEntity("TokenExample",
  "Token"))
  bobTokensAfter.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Bob now has $amount $symbol tokens")
  }




  Step 6: Test Redemption Request 
  Workflow

  Alice requests to redeem 50 Gold 
  tokens

  println("=== Testing Redemption 
  Workflow ===")

  // Alice requests to redeem 50 Gold 
  tokens
  val redemptionReqCmd = ledger_api_utils.exercise("RequestRedemption",
  Map("redeemer" -> alice, "amount" ->
  50), goldRegistry.event)

  participant1.ledger_api.commands.submit(Seq(alice, bank), Seq(redemptionReqCmd))
  println("✓ Alice requested redemption 
  of 50 GLD tokens")

  Check pending redemption request

  // Check pending redemption request
  val pendingRedemptions =
  participant1.ledger_api.acs.of_party(bank).filter(_.templateId.isModuleEntity("TokenExample", "RedeemRequest"))

  pendingRedemptions.foreach { req =>
    val owner = req.arguments("owner")
    val symbol = req.arguments("symbol")
    val amount = req.arguments("amount")
    println(s"Pending redemption: $owner wants to redeem $amount $symbol")
  }

  Step 7: Test Admin Redemption 
  Management

  Test canceling a redemption (returns 
  tokens to user)

  println("=== Testing Redemption 
  Cancellation ===")

  // Get the pending redemption request
  val pendingReq =pendingRedemptions.head

  // Bank cancels the redemption request
  val cancelCmd =
  ledger_api_utils.exercise("Cancel",
  Map(), pendingReq.event)
  participant1.ledger_api.commands.submit(Seq(bank), Seq(cancelCmd))
  println("✓ Bank canceled the 
  redemption request - tokens returned 
  to Alice")

  Check Alice's balance after 
  cancellation

  // Check Alice's tokens after cancellation



  val aliceTokensAfterCancel =
  participant1.ledger_api.acs.of_party(alice).filter(_.templateId.isModuleEntity("TokenExample", "Token"))
  aliceTokensAfterCancel.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Alice after cancellation: $amount $symbol tokens")
  }

  
   println("=== Testing Redemption 
  Acceptance ===")

  // Alice makes another redemption request (for 40 GLD this time)
  val redemptionReq2Cmd = ledger_api_utils.exercise("RequestRedemption",
  Map("redeemer" -> alice, "amount" ->
  40), goldRegistry.event)

  participant1.ledger_api.commands.submit(Seq(alice, bank), Seq(redemptionReq2Cmd))
  println("✓ Alice made another 
  redemption request for 40 GLD")



  // Get the new pending redemption request

  val pendingRedemptions2 =
  participant1.ledger_api.acs.of_party(bank).filter(_.templateId.isModuleEntity("TokenExample", "RedeemRequest"))
  
  
  val pendingReq2 =pendingRedemptions2.head

  // Bank accepts the redemption (burns  the tokens)
  val acceptCmd =
  ledger_api_utils.exercise("Accept",
  Map(), pendingReq2.event)
  participant1.ledger_api.commands.submit(Seq(bank), Seq(acceptCmd))
  println("✓ Bank accepted the 
  redemption request - 40 GLD tokens 
  burned")

  Step 8: Final Balance Check

  println("=== Final Token Balances 
  ===")

  // Final balance check for Alice
  val aliceTokensFinal =
  participant1.ledger_api.acs.of_party(alice).filter(_.templateId.isModuleEntity("TokenExample", "Token"))
 
  aliceTokensFinal.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Alice final balance: $amount $symbol tokens")
  }

  // Final balance check for Bob
  val bobTokensFinal = participant1.ledger_api.acs.of_party(bob).filter(_.templateId.isModuleEntity("TokenExample",
  "Token"))
  bobTokensFinal.foreach { token =>
    val symbol =
  token.arguments("symbol")
    val amount =
  token.arguments("amount")
    println(s"Bob final balance: $amount $symbol tokens")
  }

  println("=== RWA Platform Testing 
  Complete! ===")

  Step 9: Test Edge Cases (Optional)

  Test insufficient balance transfer

  println("=== Testing Edge Cases ===")

  // Try to transfer more tokens than  Alice has (should fail)
  val invalidTransferCmd =
  ledger_api_utils.exercise("Transfer",
  Map("sender" -> alice, "recipient" ->
  bob, "amount" -> 1000),
  goldRegistry.event)

  try {
    participant1.ledger_api.commands.submit(Seq(alice, bank),
  Seq(invalidTransferCmd))
    println("❌ Transfer should have failed but didn't")
  } catch {
    case e: Exception => println("✓ Transfer correctly failed with insufficient balance")
  }

  Test duplicate redemption request

  // Alice tries to make another  redemption request while one is 

  pending (should fail if any pending)
  try {
    val duplicateRedemptionCmd =
  ledger_api_utils.exercise("RequestRedemption", Map("redeemer" -> alice,
  "amount" -> 10), goldRegistry.event)
    participant1.ledger_api.commands.submit(Seq(alice, bank),
  Seq(duplicateRedemptionCmd))
    println("✓ Multiple redemption requests allowed (no pending  requests)")
  } catch {
    case e: Exception => println("✓ Duplicate redemption request correctly rejected")
  }





source jwt-tokens-shell.txt && curl -X POST http://localhost:7575/v1/query \
-H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
-H "Content-Type: application/json" \
-d '{
"templateIds": ["323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:Token"],
"query": {"owner": "NewAlice::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d"}}'


 curl -X POST http://localhost:7575/v1/query \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateIds": ["323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:Token"], "query": {"owner": 
  "NewAlice::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d"}}'



curl -X GET http://localhost:7575/v1/parties \
    -H "Authorization: Bearer $PARTICIPANT_ADMIN_TOKEN" \
    -H "Content-Type: application/json"


    curl -X POST http://37.27.190.172/v1/query \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateIds": ["323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:Token"]}'




    curl -X POST http://localhost:7575/v1/query \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateIds": ["323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:AssetRegistry"]}'



    curl -X POST http://localhost:7575/v1/query \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateIds": ["323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:RedeemRequest"]}'



    curl -X POST http://localhost:7575/v1/create \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateId": "323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:AssetRegistry", "payload": 
  {"admin": "NewBank::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d", "name": "Gold Token", "symbol": "GLD"}}'



  curl -X POST http://localhost:7575/v1/create \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateId": "323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:AssetRegistry", "payload": 
  {"admin": "NewBank::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d", "name": "Silver Token", "symbol": "SLV"}}'



   curl -X POST http://localhost:7575/v1/exercise \
    -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateId": "323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:AssetRegistry", "contractId": "000ea9c074d4a1b8d539b5e3a0f21a8c7969da32cf0f81174ee0c210c34c59c08bca0312209161ca4f9f6ea7821c32ed296826bd1a57a08a337cb158d146edc2e803aed82b", "choice": "Mint", "argument": {"to": "NewAlice::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d", "amount": 100}}'



curl -s -X POST http://localhost:7575/v1/query \
  -H "Authorization: Bearer $BANK_ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "templateIds": ["323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:AssetRegistry"]
  }' | jq


    curl -X POST http://localhost:7575/v1/exercise \
    -H "Authorization: Bearer $ALICE_USER_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"templateId": "323be96aa0b9cd4a6f9cf17a5096b7a69c0cc2da28d31baa5e53c72f2c8ce9c1:TokenExample:AssetRegistry", "contractId": "0043617d711682dd60fc0e9e22b482af77dbb80af5c9c24ab1e68dd8d8013cf532ca031220d2d1e28a7762c2ebe6e38ee813714321e0bba37e4cc06bb9d8cfccf9d0b8bee6", "choice": "Transfer", "argument": {"sender": 
  "NewAlice::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d", "recipient": "NewBob::1220b845dcf0d9cf52ce1e7457a744a6f3de7eff4a9ee95261b69405d1e0de8a768d", "amount": 30}}'